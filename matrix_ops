// CFG for matrix_ops.c
digraph {
	B0 [label="B0:\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <string.h>\n#define MAX 10\n#define FNAME_SZ 128\nint safe_int_read(const char *prompt) {\nint x;\nint ok;" shape=box]
	B1 [label="B1:\nwhile (1) {" shape=box]
	B2 [label="B2:\nprintf(\"%s\", prompt);\nok = scanf(\"%d\", &x);" shape=box]
	B3 [label="B3:\nif (ok == 1) {" shape=box]
	B4 [label="B4:\nint c;" shape=box]
	B5 [label="B5:\nwhile ((c = getchar()) != '\n' && c != EOF) {}" shape=box]
	B6 [label="B6:\nreturn x;" shape=box]
	B7 [label="B7:\n} else {\nprintf(\"Invalid input. Please enter an integer.\n\");\nint c;" shape=box]
	B8 [label="B8:\nwhile ((c = getchar()) != '\n' && c != EOF) {}" shape=box]
	B9 [label="B9:\n}\n}\n}\nvoid printMatrix(int a[MAX][MAX], int r, int c) {" shape=box]
	B10 [label="B10:\nfor (int i = 0; i < r; ++i) {" shape=box]
	B11 [label="B11:\nfor (int j = 0; j < c; ++j) {" shape=box]
	B12 [label="B12:\nprintf(\"%6d \", a[i][j]);\n}\nprintf(\"\n\");\n}\n}\nvoid readMatrix(int a[MAX][MAX], int r, int c) {" shape=box]
	B13 [label="B13:\nfor (int i = 0; i < r; ++i) {" shape=box]
	B14 [label="B14:\nfor (int j = 0; j < c; ++j) {" shape=box]
	B15 [label="B15:\nchar prompt[64];\nsnprintf(prompt, sizeof(prompt), \"Enter element [%d][%d]: \", i, j);\na[i][j] = safe_int_read(prompt);\n}\n}\n}\nvoid randomFill(int a[MAX][MAX], int r, int c, int range) {" shape=box]
	B16 [label="B16:\nfor (int i = 0; i < r; ++i)" shape=box]
	B17 [label="B17:\nfor (int j = 0; j < c; ++j)" shape=box]
	B18 [label="B18:\na[i][j] = (rand() % (2*range + 1)) - range;\n}\nint saveMatrixToFile(const char *fname, int a[MAX][MAX], int r, int c) {\nFILE *fp = fopen(fname, \"w\");" shape=box]
	B19 [label="B19:\nif (!fp) return -1;" shape=box]
	B20 [label="B20:\nfprintf(fp, \"%d %d\n\", r, c);" shape=box]
	B21 [label="B21:\nfor (int i = 0; i < r; ++i) {" shape=box]
	B22 [label="B22:\nfor (int j = 0; j < c; ++j) {" shape=box]
	B23 [label="B23:\nfprintf(fp, \"%d \", a[i][j]);\n}\nfprintf(fp, \"\n\");\n}\nfclose(fp);\nreturn 0;" shape=box]
	B24 [label="B24:\n}\nint loadMatrixFromFile(const char *fname, int a[MAX][MAX], int *r, int *c) {\nFILE *fp = fopen(fname, \"r\");" shape=box]
	B25 [label="B25:\nif (!fp) return -1;" shape=box]
	B26 [label="B26:\nif (fscanf(fp, \"%d %d\", r, c) != 2) {" shape=box]
	B27 [label="B27:\nfclose(fp);\nreturn -2;" shape=box]
	B28 [label="B28:\n}" shape=box]
	B29 [label="B29:\nif (*r < 0 || *r > MAX || *c < 0 || *c > MAX) {" shape=box]
	B30 [label="B30:\nfclose(fp);\nreturn -3;" shape=box]
	B31 [label="B31:\n}" shape=box]
	B32 [label="B32:\nfor (int i = 0; i < *r; ++i) {" shape=box]
	B33 [label="B33:\nfor (int j = 0; j < *c; ++j) {" shape=box]
	B34 [label="B34:\nif (fscanf(fp, \"%d\", &a[i][j]) != 1) {" shape=box]
	B35 [label="B35:\nfclose(fp);\nreturn -4;" shape=box]
	B36 [label="B36:\n}\n}\n}\nfclose(fp);\nreturn 0;" shape=box]
	B37 [label="B37:\n}\nvoid addMatrix(int a[MAX][MAX], int b[MAX][MAX], int res[MAX][MAX], int r, int c) {" shape=box]
	B38 [label="B38:\nfor (int i = 0; i < r; ++i)" shape=box]
	B39 [label="B39:\nfor (int j = 0; j < c; ++j)" shape=box]
	B40 [label="B40:\nres[i][j] = a[i][j] + b[i][j];\n}\nvoid subMatrix(int a[MAX][MAX], int b[MAX][MAX], int res[MAX][MAX], int r, int c) {" shape=box]
	B41 [label="B41:\nfor (int i = 0; i < r; ++i)" shape=box]
	B42 [label="B42:\nfor (int j = 0; j < c; ++j)" shape=box]
	B43 [label="B43:\nres[i][j] = a[i][j] - b[i][j];\n}\nvoid multMatrix(int a[MAX][MAX], int b[MAX][MAX], int res[MAX][MAX], int r1, int c1, int c2) {" shape=box]
	B44 [label="B44:\nfor (int i = 0; i < r1; ++i) {" shape=box]
	B45 [label="B45:\nfor (int j = 0; j < c2; ++j) {" shape=box]
	B46 [label="B46:\nres[i][j] = 0;" shape=box]
	B47 [label="B47:\nfor (int k = 0; k < c1; ++k) {" shape=box]
	B48 [label="B48:\nres[i][j] += a[i][k] * b[k][j];\n}\n}\n}\n}\nvoid scalarMultiply(int a[MAX][MAX], int res[MAX][MAX], int r, int c, int scalar) {" shape=box]
	B49 [label="B49:\nfor (int i = 0; i < r; ++i)" shape=box]
	B50 [label="B50:\nfor (int j = 0; j < c; ++j)" shape=box]
	B51 [label="B51:\nres[i][j] = a[i][j] * scalar;\n}\nvoid transpose(int a[MAX][MAX], int res[MAX][MAX], int r, int c) {" shape=box]
	B52 [label="B52:\nfor (int i = 0; i < r; ++i)" shape=box]
	B53 [label="B53:\nfor (int j = 0; j < c; ++j)" shape=box]
	B54 [label="B54:\nres[j][i] = a[i][j];\n}\nvoid copyMatrix(int src[MAX][MAX], int dst[MAX][MAX], int r, int c) {" shape=box]
	B55 [label="B55:\nfor (int i = 0; i < r; ++i)" shape=box]
	B56 [label="B56:\nfor (int j = 0; j < c; ++j)" shape=box]
	B57 [label="B57:\ndst[i][j] = src[i][j];\n}\nint determinant_recursive(int mat[MAX][MAX], int n) {" shape=box]
	B58 [label="B58:\nif (n == 1) {" shape=box]
	B59 [label="B59:\nreturn mat[0][0];" shape=box]
	B60 [label="B60:\n}" shape=box]
	B61 [label="B61:\nif (n == 2) {" shape=box]
	B62 [label="B62:\nreturn mat[0][0]*mat[1][1] - mat[0][1]*mat[1][0];" shape=box]
	B63 [label="B63:\n}\nint det = 0;\nint temp[MAX][MAX];" shape=box]
	B64 [label="B64:\nfor (int p = 0; p < n; p++) {" shape=box]
	B65 [label="B65:\nint subi = 0;" shape=box]
	B66 [label="B66:\nfor (int i = 1; i < n; i++) {" shape=box]
	B67 [label="B67:\nint subj = 0;" shape=box]
	B68 [label="B68:\nfor (int j = 0; j < n; j++) {" shape=box]
	B69 [label="B69:\nif (j == p) continue;" shape=box]
	B70 [label="B70:\ntemp[subi][subj] = mat[i][j];\nsubj++;\n}\nsubi++;\n}\nint sign = (p % 2 == 0) ? 1 : -1;\ndet += sign * mat[0][p] * determinant_recursive(temp, n-1);\n}\nreturn det;" shape=box]
	B71 [label="B71:\n}\nvoid printHeader(const char *title) {\nprintf(\"\n================ %s ================\n\", title);\n}\nint dims_equal(int r1, int c1, int r2, int c2) {\nreturn r1 == r2 && c1 == c2;" shape=box]
	B72 [label="B72:\n}\nint main(void) {\nint A[MAX][MAX] = {0}, B[MAX][MAX] = {0}, R[MAX][MAX] = {0};\nint r1 = 0, c1 = 0, r2 = 0, c2 = 0;\nint choice;\nchar fname[FNAME_SZ];\nsrand((unsigned)time(NULL));\nprintHeader(\"Matrix Operations - Extended\");" shape=box]
	B73 [label="B73:\nwhile (1) {" shape=box]
	B74 [label="B74:\nprintf(\"\nInitial setup:\n\");\nprintf(\"1. Enter sizes and elements for matrices A and B manually\n\");\nprintf(\"2. Random fill matrices A and B\n\");\nprintf(\"3. Load matrices from files\n\");\nprintf(\"4. Exit program\n\");\nint init_choice = safe_int_read(\"Choice: \");" shape=box]
	B75 [label="B75:\nif (init_choice == 1) {" shape=box]
	B76 [label="B76:\nr1 = safe_int_read(\"Enter rows for matrix A (1..10): \");\nc1 = safe_int_read(\"Enter cols for matrix A (1..10): \");" shape=box]
	B77 [label="B77:\nif (r1 <= 0 || r1 > MAX || c1 <= 0 || c1 > MAX) {" shape=box]
	B78 [label="B78:\nprintf(\"Invalid dimensions. Try again.\n\");\ncontinue;\n}\nprintf(\"Enter Matrix A:\n\");\nreadMatrix(A, r1, c1);\nr2 = safe_int_read(\"Enter rows for matrix B (1..10): \");\nc2 = safe_int_read(\"Enter cols for matrix B (1..10): \");" shape=box]
	B79 [label="B79:\nif (r2 <= 0 || r2 > MAX || c2 <= 0 || c2 > MAX) {" shape=box]
	B80 [label="B80:\nprintf(\"Invalid dimensions for B. Try again.\n\");\ncontinue;\n}\nprintf(\"Enter Matrix B:\n\");\nreadMatrix(B, r2, c2);\nbreak;\n} else if (init_choice == 2) {\nr1 = safe_int_read(\"Enter rows for matrix A (1..10): \");\nc1 = safe_int_read(\"Enter cols for matrix A (1..10): \");\nr2 = safe_int_read(\"Enter rows for matrix B (1..10): \");\nc2 = safe_int_read(\"Enter cols for matrix B (1..10): \");\nint rng = safe_int_read(\"Enter random range (positive integer): \");" shape=box]
	B81 [label="B81:\nif (rng < 0) rng = 10;" shape=box]
	B82 [label="B82:\nrandomFill(A, r1, c1, rng);\nrandomFill(B, r2, c2, rng);\nprintf(\"Matrices random-filled.\n\");\nbreak;\n} else if (init_choice == 3) {\nprintf(\"Enter file name for matrix A: \");" shape=box]
	B83 [label="B83:\nif (scanf(\"%127s\", fname) != 1) { printf(\"Read error.\n\"); continue; }" shape=box]
	B84 [label="B84:\nint ret = loadMatrixFromFile(fname, A, &r1, &c1);" shape=box]
	B85 [label="B85:\nif (ret != 0) { printf(\"Failed to load A from %s (err=%d)\n\", fname, ret); continue; }" shape=box]
	B86 [label="B86:\nprintf(\"Enter file name for matrix B: \");" shape=box]
	B87 [label="B87:\nif (scanf(\"%127s\", fname) != 1) { printf(\"Read error.\n\"); continue; }" shape=box]
	B88 [label="B88:\nret = loadMatrixFromFile(fname, B, &r2, &c2);" shape=box]
	B89 [label="B89:\nif (ret != 0) { printf(\"Failed to load B from %s (err=%d)\n\", fname, ret); continue; }" shape=box]
	B90 [label="B90:\nprintf(\"Loaded A (%d x %d) and B (%d x %d)\n\", r1, c1, r2, c2);\nbreak;\n} else if (init_choice == 4) {\nprintf(\"Goodbye.\n\");\nreturn 0;" shape=box]
	B91 [label="B91:\n} else {\nprintf(\"Try again.\n\");\n}\n}" shape=box]
	B92 [label="B92:\nwhile (1) {" shape=box]
	B93 [label="B93:\nprintHeader(\"Main Menu\");\nprintf(\"A: dims A = %d x %d | B: dims B = %d x %d\n\", r1, c1, r2, c2);\nprintf(\"1. Print matrices\n\");\nprintf(\"2. Add (A+B)\n\");\nprintf(\"3. Subtract (A-B)\n\");\nprintf(\"4. Multiply (A*B)\n\");\nprintf(\"5. Scalar multiply A\n\");\nprintf(\"6. Transpose A\n\");\nprintf(\"7. Determinant of A (must be square)\n\");\nprintf(\"8. Save a matrix to file\n\");\nprintf(\"9. Load matrix from file into A or B\n\");\nprintf(\"10. Swap A and B\n\");\nprintf(\"11. Re-enter matrices\n\");\nprintf(\"12. Exit\n\");\nchoice = safe_int_read(\"Enter choice: \");" shape=box]
	B94 [label="B94:\nif (choice == 1) {" shape=box]
	B95 [label="B95:\nprintf(\"\nMatrix A:\n\");\nprintMatrix(A, r1, c1);\nprintf(\"\nMatrix B:\n\");\nprintMatrix(B, r2, c2);\n} else if (choice == 2) {" shape=box]
	B96 [label="B96:\nif (!dims_equal(r1, c1, r2, c2)) {" shape=box]
	B97 [label="B97:\nprintf(\"Dimensions must be equal for addition.\n\");\n} else {\naddMatrix(A, B, R, r1, c1);\nprintf(\"Result (A+B):\n\");\nprintMatrix(R, r1, c1);\n}\n} else if (choice == 3) {" shape=box]
	B98 [label="B98:\nif (!dims_equal(r1, c1, r2, c2)) {" shape=box]
	B99 [label="B99:\nprintf(\"Dimensions must be equal for subtraction.\n\");\n} else {\nsubMatrix(A, B, R, r1, c1);\nprintf(\"Result (A-B):\n\");\nprintMatrix(R, r1, c1);\n}\n} else if (choice == 4) {" shape=box]
	B100 [label="B100:\nif (c1 != r2) {" shape=box]
	B101 [label="B101:\nprintf(\"For multiplication A(c1) must equal B(r2).\n\");\n} else {\nmultMatrix(A, B, R, r1, c1, c2);\nprintf(\"Result (A*B):\n\");\nprintMatrix(R, r1, c2);\n}\n} else if (choice == 5) {\nint scalar = safe_int_read(\"Enter scalar: \");\nscalarMultiply(A, R, r1, c1, scalar);\nprintf(\"Result (scalar * A):\n\");\nprintMatrix(R, r1, c1);\n} else if (choice == 6) {\ntranspose(A, R, r1, c1);\nprintf(\"Transpose of A (size %d x %d):\n\", c1, r1);\nprintMatrix(R, c1, r1);\n} else if (choice == 7) {" shape=box]
	B102 [label="B102:\nif (r1 != c1) {" shape=box]
	B103 [label="B103:\nprintf(\"Determinant defined only for square matrices.\n\");\n} else {" shape=box]
	B104 [label="B104:\nif (r1 > 8) {" shape=box]
	B105 [label="B105:\nprintf(\"Matrix too large for naive det routine (limit = 8).\n\");\n} else {\nint det = determinant_recursive(A, r1);\nprintf(\"Determinant of A is %d\n\", det);\n}\n}\n} else if (choice == 8) {\nprintf(\"Which matrix to save? (A/B): \");\nchar ch;" shape=box]
	B106 [label="B106:\nif (scanf(\" %c\", &ch) != 1) { printf(\"Read error\n\"); continue; }" shape=box]
	B107 [label="B107:\nprintf(\"Enter filename: \");" shape=box]
	B108 [label="B108:\nif (scanf(\"%127s\", fname) != 1) { printf(\"Read error\n\"); continue; }" shape=box]
	B109 [label="B109:\nint ret;" shape=box]
	B110 [label="B110:\nif (ch == 'A' || ch == 'a') ret = saveMatrixToFile(fname, A, r1, c1);" shape=box]
	B111 [label="B111:\nelse ret = saveMatrixToFile(fname, B, r2, c2);" shape=box]
	B112 [label="B112:\nif (ret == 0) printf(\"Saved successfully.\n\");" shape=box]
	B113 [label="B113:\nelse printf(\"Failed to save.\n\");" shape=box]
	B114 [label="B114:\n} else if (choice == 9) {\nprintf(\"Load into which matrix? (A/B): \");\nchar ch;" shape=box]
	B115 [label="B115:\nif (scanf(\" %c\", &ch) != 1) { printf(\"Read error\n\"); continue; }" shape=box]
	B116 [label="B116:\nprintf(\"Enter filename: \");" shape=box]
	B117 [label="B117:\nif (scanf(\"%127s\", fname) != 1) { printf(\"Read error\n\"); continue; }" shape=box]
	B118 [label="B118:\nint rr, cc;\nint ret = loadMatrixFromFile(fname, R, &rr, &cc);" shape=box]
	B119 [label="B119:\nif (ret != 0) {" shape=box]
	B120 [label="B120:\nprintf(\"Failed to load (err=%d)\n\", ret);\n} else {" shape=box]
	B121 [label="B121:\nif (ch == 'A' || ch == 'a') {" shape=box]
	B122 [label="B122:\nr1 = rr; c1 = cc; copyMatrix(R, A, r1, c1);\n} else {\nr2 = rr; c2 = cc; copyMatrix(R, B, r2, c2);\n}\nprintf(\"Loaded successfully into %c\n\", ch);\n}\n} else if (choice == 10) {\nint tempA[MAX][MAX];\nint tempB[MAX][MAX];\nint tr = r1, tc = c1;\ncopyMatrix(A, tempA, r1, c1);\ncopyMatrix(B, tempB, r2, c2);\ncopyMatrix(tempA, B, r1, c1);\ncopyMatrix(tempB, A, r2, c2);\nr1 = r2; c1 = c2;\nr2 = tr; c2 = tc;\nprintf(\"Swapped A and B.\n\");\n} else if (choice == 11) {\nr1 = safe_int_read(\"Enter rows for matrix A (1..10): \");\nc1 = safe_int_read(\"Enter cols for matrix A (1..10): \");" shape=box]
	B123 [label="B123:\nif (r1 <= 0 || r1 > MAX || c1 <= 0 || c1 > MAX) { printf(\"Invalid dims\n\"); continue; }" shape=box]
	B124 [label="B124:\nprintf(\"Enter Matrix A:\n\");\nreadMatrix(A, r1, c1);\nr2 = safe_int_read(\"Enter rows for matrix B (1..10): \");\nc2 = safe_int_read(\"Enter cols for matrix B (1..10): \");" shape=box]
	B125 [label="B125:\nif (r2 <= 0 || r2 > MAX || c2 <= 0 || c2 > MAX) { printf(\"Invalid dims\n\"); continue; }" shape=box]
	B126 [label="B126:\nprintf(\"Enter Matrix B:\n\");\nreadMatrix(B, r2, c2);\n} else if (choice == 12) {\nprintf(\"Exiting program.\n\");\nbreak;\n} else {\nprintf(\"Invalid option. Try again.\n\");\n}\n}\nreturn 0;" shape=box]
	B127 [label="B127:\n}" shape=box]
	B0 -> B1 [label=""]
	B1 -> B2 [label="loop-body"]
	B2 -> B1 [label="back-edge"]
	B2 -> B3 [label=""]
	B3 -> B4 [label=true]
	B3 -> B5 [label=false]
	B4 -> B5 [label=""]
	B5 -> B6 [label="loop-body"]
	B6 -> B5 [label="back-edge"]
	B7 -> B8 [label=""]
	B8 -> B9 [label="loop-body"]
	B9 -> B8 [label="back-edge"]
	B9 -> B10 [label=""]
	B10 -> B11 [label="loop-body"]
	B11 -> B10 [label="back-edge"]
	B11 -> B12 [label="loop-body"]
	B12 -> B11 [label="back-edge"]
	B12 -> B13 [label=""]
	B13 -> B14 [label="loop-body"]
	B14 -> B13 [label="back-edge"]
	B14 -> B15 [label="loop-body"]
	B15 -> B14 [label="back-edge"]
	B15 -> B16 [label=""]
	B16 -> B17 [label="loop-body"]
	B17 -> B16 [label="back-edge"]
	B17 -> B18 [label="loop-body"]
	B18 -> B17 [label="back-edge"]
	B18 -> B19 [label=""]
	B19 -> B20 [label=true]
	B19 -> B21 [label=false]
	B20 -> B21 [label=""]
	B21 -> B22 [label="loop-body"]
	B22 -> B21 [label="back-edge"]
	B22 -> B23 [label="loop-body"]
	B23 -> B22 [label="back-edge"]
	B24 -> B25 [label=""]
	B25 -> B26 [label=true]
	B25 -> B27 [label=false]
	B26 -> B27 [label=true]
	B26 -> B28 [label=false]
	B28 -> B29 [label=""]
	B29 -> B30 [label=true]
	B29 -> B31 [label=false]
	B31 -> B32 [label=""]
	B32 -> B33 [label="loop-body"]
	B33 -> B32 [label="back-edge"]
	B33 -> B34 [label="loop-body"]
	B34 -> B33 [label="back-edge"]
	B34 -> B35 [label=true]
	B34 -> B36 [label=false]
	B37 -> B38 [label=""]
	B38 -> B39 [label="loop-body"]
	B39 -> B38 [label="back-edge"]
	B39 -> B40 [label="loop-body"]
	B40 -> B39 [label="back-edge"]
	B40 -> B41 [label=""]
	B41 -> B42 [label="loop-body"]
	B42 -> B41 [label="back-edge"]
	B42 -> B43 [label="loop-body"]
	B43 -> B42 [label="back-edge"]
	B43 -> B44 [label=""]
	B44 -> B45 [label="loop-body"]
	B45 -> B44 [label="back-edge"]
	B45 -> B46 [label="loop-body"]
	B46 -> B45 [label="back-edge"]
	B46 -> B47 [label=""]
	B47 -> B48 [label="loop-body"]
	B48 -> B47 [label="back-edge"]
	B48 -> B49 [label=""]
	B49 -> B50 [label="loop-body"]
	B50 -> B49 [label="back-edge"]
	B50 -> B51 [label="loop-body"]
	B51 -> B50 [label="back-edge"]
	B51 -> B52 [label=""]
	B52 -> B53 [label="loop-body"]
	B53 -> B52 [label="back-edge"]
	B53 -> B54 [label="loop-body"]
	B54 -> B53 [label="back-edge"]
	B54 -> B55 [label=""]
	B55 -> B56 [label="loop-body"]
	B56 -> B55 [label="back-edge"]
	B56 -> B57 [label="loop-body"]
	B57 -> B56 [label="back-edge"]
	B57 -> B58 [label=""]
	B58 -> B59 [label=true]
	B58 -> B60 [label=false]
	B60 -> B61 [label=""]
	B61 -> B62 [label=true]
	B61 -> B63 [label=false]
	B63 -> B64 [label=""]
	B64 -> B65 [label="loop-body"]
	B65 -> B64 [label="back-edge"]
	B65 -> B66 [label=""]
	B66 -> B67 [label="loop-body"]
	B67 -> B66 [label="back-edge"]
	B67 -> B68 [label=""]
	B68 -> B69 [label="loop-body"]
	B69 -> B68 [label="back-edge"]
	B69 -> B70 [label=true]
	B69 -> B71 [label=false]
	B72 -> B73 [label=""]
	B73 -> B74 [label="loop-body"]
	B74 -> B73 [label="back-edge"]
	B74 -> B75 [label=""]
	B75 -> B76 [label=true]
	B75 -> B77 [label=false]
	B76 -> B77 [label=""]
	B77 -> B78 [label=true]
	B77 -> B79 [label=false]
	B78 -> B79 [label=""]
	B79 -> B80 [label=true]
	B79 -> B81 [label=false]
	B80 -> B81 [label=""]
	B81 -> B82 [label=true]
	B81 -> B83 [label=false]
	B82 -> B83 [label=""]
	B83 -> B84 [label=true]
	B83 -> B85 [label=false]
	B84 -> B85 [label=""]
	B85 -> B86 [label=true]
	B85 -> B87 [label=false]
	B86 -> B87 [label=""]
	B87 -> B88 [label=true]
	B87 -> B89 [label=false]
	B88 -> B89 [label=""]
	B89 -> B90 [label=true]
	B89 -> B91 [label=false]
	B91 -> B92 [label=""]
	B92 -> B93 [label="loop-body"]
	B93 -> B92 [label="back-edge"]
	B93 -> B94 [label=""]
	B94 -> B95 [label=true]
	B94 -> B96 [label=false]
	B95 -> B96 [label=true]
	B95 -> B97 [label=false]
	B96 -> B97 [label=true]
	B96 -> B98 [label=false]
	B97 -> B98 [label=true]
	B97 -> B99 [label=false]
	B98 -> B99 [label=true]
	B98 -> B100 [label=false]
	B99 -> B100 [label=true]
	B99 -> B101 [label=false]
	B100 -> B101 [label=true]
	B100 -> B102 [label=false]
	B101 -> B102 [label=true]
	B101 -> B103 [label=false]
	B102 -> B103 [label=true]
	B102 -> B104 [label=false]
	B103 -> B104 [label=""]
	B104 -> B105 [label=true]
	B104 -> B106 [label=false]
	B105 -> B106 [label=""]
	B106 -> B107 [label=true]
	B106 -> B108 [label=false]
	B107 -> B108 [label=""]
	B108 -> B109 [label=true]
	B108 -> B110 [label=false]
	B109 -> B110 [label=""]
	B110 -> B111 [label=true]
	B110 -> B112 [label=false]
	B111 -> B112 [label=""]
	B112 -> B113 [label=true]
	B112 -> B114 [label=false]
	B113 -> B114 [label=""]
	B114 -> B115 [label=""]
	B115 -> B116 [label=true]
	B115 -> B117 [label=false]
	B116 -> B117 [label=""]
	B117 -> B118 [label=true]
	B117 -> B119 [label=false]
	B118 -> B119 [label=""]
	B119 -> B120 [label=true]
	B119 -> B121 [label=false]
	B120 -> B121 [label=""]
	B121 -> B122 [label=true]
	B121 -> B123 [label=false]
	B122 -> B123 [label=""]
	B123 -> B124 [label=true]
	B123 -> B125 [label=false]
	B124 -> B125 [label=""]
	B125 -> B126 [label=true]
	B125 -> B127 [label=false]
}
