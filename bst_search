// CFG for bst_search.c
digraph {
	B0 [label="B0:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct Node {\nint key;\nstruct Node *left;\nstruct Node *right;\n};\nstruct Node* newNode(int key) {\nstruct Node* n = (struct Node*)malloc(sizeof(struct Node));" shape=box]
	B1 [label="B1:\nif (!n) { perror(\"malloc\"); exit(1); }" shape=box]
	B2 [label="B2:\nn->key = key;\nn->left = n->right = NULL;\nreturn n;" shape=box]
	B3 [label="B3:\n}\nstruct Node* insert_recursive(struct Node* root, int key) {" shape=box]
	B4 [label="B4:\nif (root == NULL) return newNode(key);" shape=box]
	B5 [label="B5:\nif (key < root->key) root->left = insert_recursive(root->left, key);" shape=box]
	B6 [label="B6:\nelse if (key > root->key) root->right = insert_recursive(root->right, key);" shape=box]
	B7 [label="B7:\nreturn root;" shape=box]
	B8 [label="B8:\n}\nstruct Node* insert_iterative(struct Node* root, int key) {" shape=box]
	B9 [label="B9:\nif (root == NULL) return newNode(key);" shape=box]
	B10 [label="B10:\nstruct Node* cur = root;\nstruct Node* parent = NULL;" shape=box]
	B11 [label="B11:\nwhile (cur) {" shape=box]
	B12 [label="B12:\nparent = cur;" shape=box]
	B13 [label="B13:\nif (key < cur->key) cur = cur->left;" shape=box]
	B14 [label="B14:\nelse if (key > cur->key) cur = cur->right;" shape=box]
	B15 [label="B15:\nelse return root;" shape=box]
	B16 [label="B16:\n}" shape=box]
	B17 [label="B17:\nif (key < parent->key) parent->left = newNode(key);" shape=box]
	B18 [label="B18:\nelse parent->right = newNode(key);" shape=box]
	B19 [label="B19:\nreturn root;" shape=box]
	B20 [label="B20:\n}\nstruct Node* search_recursive(struct Node* root, int key) {" shape=box]
	B21 [label="B21:\nif (root == NULL || root->key == key) return root;" shape=box]
	B22 [label="B22:\nif (key < root->key) return search_recursive(root->left, key);" shape=box]
	B23 [label="B23:\nelse return search_recursive(root->right, key);" shape=box]
	B24 [label="B24:\n}\nstruct Node* minValueNode(struct Node* node) {\nstruct Node* cur = node;" shape=box]
	B25 [label="B25:\nwhile (cur && cur->left) cur = cur->left;" shape=box]
	B26 [label="B26:\nreturn cur;" shape=box]
	B27 [label="B27:\n}\nstruct Node* deleteNode(struct Node* root, int key) {" shape=box]
	B28 [label="B28:\nif (root == NULL) return root;" shape=box]
	B29 [label="B29:\nif (key < root->key) root->left = deleteNode(root->left, key);" shape=box]
	B30 [label="B30:\nelse if (key > root->key) root->right = deleteNode(root->right, key);" shape=box]
	B31 [label="B31:\nelse {" shape=box]
	B32 [label="B32:\nif (root->left == NULL) {" shape=box]
	B33 [label="B33:\nstruct Node* temp = root->right;\nfree(root);\nreturn temp;" shape=box]
	B34 [label="B34:\n} else if (root->right == NULL) {\nstruct Node* temp = root->left;\nfree(root);\nreturn temp;" shape=box]
	B35 [label="B35:\n}\nstruct Node* temp = minValueNode(root->right);\nroot->key = temp->key;\nroot->right = deleteNode(root->right, temp->key);\n}\nreturn root;" shape=box]
	B36 [label="B36:\n}\nvoid inorder(struct Node* root) {" shape=box]
	B37 [label="B37:\nif (!root) return;" shape=box]
	B38 [label="B38:\ninorder(root->left);\nprintf(\"%d \", root->key);\ninorder(root->right);\n}\nvoid preorder(struct Node* root) {" shape=box]
	B39 [label="B39:\nif (!root) return;" shape=box]
	B40 [label="B40:\nprintf(\"%d \", root->key);\npreorder(root->left);\npreorder(root->right);\n}\nvoid postorder(struct Node* root) {" shape=box]
	B41 [label="B41:\nif (!root) return;" shape=box]
	B42 [label="B42:\npostorder(root->left);\npostorder(root->right);\nprintf(\"%d \", root->key);\n}\nint height(struct Node* root) {" shape=box]
	B43 [label="B43:\nif (!root) return 0;" shape=box]
	B44 [label="B44:\nint lh = height(root->left);\nint rh = height(root->right);\nreturn (lh > rh ? lh : rh) + 1;" shape=box]
	B45 [label="B45:\n}\nint count_nodes(struct Node* root) {" shape=box]
	B46 [label="B46:\nif (!root) return 0;" shape=box]
	B47 [label="B47:\nreturn 1 + count_nodes(root->left) + count_nodes(root->right);" shape=box]
	B48 [label="B48:\n}\nint count_leaves(struct Node* root) {" shape=box]
	B49 [label="B49:\nif (!root) return 0;" shape=box]
	B50 [label="B50:\nif (!root->left && !root->right) return 1;" shape=box]
	B51 [label="B51:\nreturn count_leaves(root->left) + count_leaves(root->right);" shape=box]
	B52 [label="B52:\n}\nstruct QueueNode {\nstruct Node *treeNode;\nstruct QueueNode *next;\n};\nvoid enqueue(struct QueueNode **head, struct QueueNode **tail, struct Node *tn) {\nstruct QueueNode *q = (struct QueueNode*)malloc(sizeof(struct QueueNode));" shape=box]
	B53 [label="B53:\nif (!q) { perror(\"malloc\"); exit(1); }" shape=box]
	B54 [label="B54:\nq->treeNode = tn;\nq->next = NULL;" shape=box]
	B55 [label="B55:\nif (!*tail) { *head = *tail = q; }" shape=box]
	B56 [label="B56:\nelse { (*tail)->next = q; *tail = q; }" shape=box]
	B57 [label="B57:\n}\nstruct Node* dequeue(struct QueueNode **head, struct QueueNode **tail) {" shape=box]
	B58 [label="B58:\nif (!*head) return NULL;" shape=box]
	B59 [label="B59:\nstruct QueueNode *tmp = *head;\nstruct Node *tn = tmp->treeNode;\n*head = (*head)->next;" shape=box]
	B60 [label="B60:\nif (!*head) *tail = NULL;" shape=box]
	B61 [label="B61:\nfree(tmp);\nreturn tn;" shape=box]
	B62 [label="B62:\n}\nvoid levelOrder(struct Node* root) {\nstruct QueueNode *head = NULL, *tail = NULL;" shape=box]
	B63 [label="B63:\nif (!root) return;" shape=box]
	B64 [label="B64:\nenqueue(&head, &tail, root);" shape=box]
	B65 [label="B65:\nwhile (head) {" shape=box]
	B66 [label="B66:\nstruct Node *n = dequeue(&head, &tail);\nprintf(\"%d \", n->key);" shape=box]
	B67 [label="B67:\nif (n->left) enqueue(&head, &tail, n->left);" shape=box]
	B68 [label="B68:\nif (n->right) enqueue(&head, &tail, n->right);" shape=box]
	B69 [label="B69:\n}\n}\nstruct Node* predecessor(struct Node* root, int key) {\nstruct Node* cur = root;\nstruct Node* pred = NULL;" shape=box]
	B70 [label="B70:\nwhile (cur) {" shape=box]
	B71 [label="B71:\nif (key > cur->key) {" shape=box]
	B72 [label="B72:\npred = cur;\ncur = cur->right;\n} else if (key < cur->key) {\ncur = cur->left;\n} else {" shape=box]
	B73 [label="B73:\nif (cur->left) {" shape=box]
	B74 [label="B74:\npred = cur->left;" shape=box]
	B75 [label="B75:\nwhile (pred->right) pred = pred->right;" shape=box]
	B76 [label="B76:\n}\nbreak;\n}\n}\nreturn pred;" shape=box]
	B77 [label="B77:\n}\nstruct Node* successor(struct Node* root, int key) {\nstruct Node* cur = root;\nstruct Node* succ = NULL;" shape=box]
	B78 [label="B78:\nwhile (cur) {" shape=box]
	B79 [label="B79:\nif (key < cur->key) {" shape=box]
	B80 [label="B80:\nsucc = cur;\ncur = cur->left;\n} else if (key > cur->key) {\ncur = cur->right;\n} else {" shape=box]
	B81 [label="B81:\nif (cur->right) {" shape=box]
	B82 [label="B82:\nsucc = cur->right;" shape=box]
	B83 [label="B83:\nwhile (succ->left) succ = succ->left;" shape=box]
	B84 [label="B84:\n}\nbreak;\n}\n}\nreturn succ;" shape=box]
	B85 [label="B85:\n}\nvoid save_tree_preorder(FILE *fp, struct Node* root) {" shape=box]
	B86 [label="B86:\nif (root == NULL) {" shape=box]
	B87 [label="B87:\nfprintf(fp, \"# \");\nreturn;" shape=box]
	B88 [label="B88:\n}\nfprintf(fp, \"%d \", root->key);\nsave_tree_preorder(fp, root->left);\nsave_tree_preorder(fp, root->right);\n}\nstruct Node* load_tree_preorder(FILE *fp) {\nchar buf[64];" shape=box]
	B89 [label="B89:\nif (!(fscanf(fp, \"%63s\", buf) == 1)) return NULL;" shape=box]
	B90 [label="B90:\nif (strcmp(buf, \"#\") == 0) return NULL;" shape=box]
	B91 [label="B91:\nint val = atoi(buf);\nstruct Node* root = newNode(val);\nroot->left = load_tree_preorder(fp);\nroot->right = load_tree_preorder(fp);\nreturn root;" shape=box]
	B92 [label="B92:\n}\nvoid free_tree(struct Node* root) {" shape=box]
	B93 [label="B93:\nif (!root) return;" shape=box]
	B94 [label="B94:\nfree_tree(root->left);\nfree_tree(root->right);\nfree(root);\n}\nint main(void) {\nstruct Node* root = NULL;\nint choice;\nint key;\nchar fname[128];\nprintf(\"=== Extended BST Program ===\n\");" shape=box]
	B95 [label="B95:\nwhile (1) {" shape=box]
	B96 [label="B96:\nprintf(\"\nMenu:\n\");\nprintf(\"1. Insert (recursive)\n\");\nprintf(\"2. Insert (iterative)\n\");\nprintf(\"3. Search\n\");\nprintf(\"4. Delete\n\");\nprintf(\"5. Traversals (in/pre/post/level)\n\");\nprintf(\"6. Statistics (height, nodes, leaves)\n\");\nprintf(\"7. Find predecessor & successor\n\");\nprintf(\"8. Save tree to file\n\");\nprintf(\"9. Load tree from file (overwrites current)\n\");\nprintf(\"10. Clear tree\n\");\nprintf(\"11. Exit\n\");\nprintf(\"Choice: \");" shape=box]
	B97 [label="B97:\nif (scanf(\"%d\", &choice) != 1) {" shape=box]
	B98 [label="B98:\nint c;" shape=box]
	B99 [label="B99:\nwhile ((c = getchar()) != '\n' && c != EOF) {}" shape=box]
	B100 [label="B100:\ncontinue;\n}" shape=box]
	B101 [label="B101:\nif (choice == 1) {" shape=box]
	B102 [label="B102:\nprintf(\"Enter key to insert: \");" shape=box]
	B103 [label="B103:\nif (scanf(\"%d\", &key) == 1) root = insert_recursive(root, key);" shape=box]
	B104 [label="B104:\n} else if (choice == 2) {\nprintf(\"Enter key to insert (iterative): \");" shape=box]
	B105 [label="B105:\nif (scanf(\"%d\", &key) == 1) root = insert_iterative(root, key);" shape=box]
	B106 [label="B106:\n} else if (choice == 3) {\nprintf(\"Enter key to search: \");" shape=box]
	B107 [label="B107:\nif (scanf(\"%d\", &key) == 1) {" shape=box]
	B108 [label="B108:\nstruct Node* found = search_recursive(root, key);" shape=box]
	B109 [label="B109:\nif (found) printf(\"Found key %d\n\", found->key);" shape=box]
	B110 [label="B110:\nelse printf(\"Key %d not found\n\", key);" shape=box]
	B111 [label="B111:\n}\n} else if (choice == 4) {\nprintf(\"Enter key to delete: \");" shape=box]
	B112 [label="B112:\nif (scanf(\"%d\", &key) == 1) {" shape=box]
	B113 [label="B113:\nroot = deleteNode(root, key);\nprintf(\"Deleted (if existed) %d\n\", key);\n}\n} else if (choice == 5) {\nprintf(\"Inorder: \");\ninorder(root);\nprintf(\"\nPreorder: \");\npreorder(root);\nprintf(\"\nPostorder: \");\npostorder(root);\nprintf(\"\nLevel-order: \");\nlevelOrder(root);\nprintf(\"\n\");\n} else if (choice == 6) {\nprintf(\"Height: %d\n\", height(root));\nprintf(\"Nodes: %d\n\", count_nodes(root));\nprintf(\"Leaves: %d\n\", count_leaves(root));\n} else if (choice == 7) {\nprintf(\"Enter key to find pred & succ: \");" shape=box]
	B114 [label="B114:\nif (scanf(\"%d\", &key) == 1) {" shape=box]
	B115 [label="B115:\nstruct Node* pred = predecessor(root, key);\nstruct Node* succ = successor(root, key);" shape=box]
	B116 [label="B116:\nif (pred) printf(\"Predecessor: %d\n\", pred->key); else printf(\"No predecessor\n\");" shape=box]
	B117 [label="B117:\nif (succ) printf(\"Successor: %d\n\", succ->key); else printf(\"No successor\n\");" shape=box]
	B118 [label="B118:\n}\n} else if (choice == 8) {\nprintf(\"Enter filename to save: \");" shape=box]
	B119 [label="B119:\nif (scanf(\"%127s\", fname) == 1) {" shape=box]
	B120 [label="B120:\nFILE *fp = fopen(fname, \"w\");" shape=box]
	B121 [label="B121:\nif (!fp) { printf(\"Failed to open file\n\"); }" shape=box]
	B122 [label="B122:\nelse { save_tree_preorder(fp, root); fclose(fp); printf(\"Saved\n\"); }" shape=box]
	B123 [label="B123:\n}\n} else if (choice == 9) {\nprintf(\"Enter filename to load: \");" shape=box]
	B124 [label="B124:\nif (scanf(\"%127s\", fname) == 1) {" shape=box]
	B125 [label="B125:\nFILE *fp = fopen(fname, \"r\");" shape=box]
	B126 [label="B126:\nif (!fp) { printf(\"Failed to open file\n\"); }" shape=box]
	B127 [label="B127:\nelse {" shape=box]
	B128 [label="B128:\nfree_tree(root);\nroot = load_tree_preorder(fp);\nfclose(fp);\nprintf(\"Loaded tree from %s\n\", fname);\n}\n}\n} else if (choice == 10) {\nfree_tree(root);\nroot = NULL;\nprintf(\"Cleared tree\n\");\n} else if (choice == 11) {\nprintf(\"Exiting.\n\");\nbreak;\n} else {\nprintf(\"Invalid choice.\n\");\n}\n}\nfree_tree(root);\nreturn 0;" shape=box]
	B129 [label="B129:\n}" shape=box]
	B0 -> B1 [label=""]
	B1 -> B2 [label=true]
	B1 -> B3 [label=false]
	B3 -> B4 [label=""]
	B4 -> B5 [label=true]
	B4 -> B6 [label=false]
	B5 -> B6 [label=true]
	B5 -> B7 [label=false]
	B6 -> B7 [label=true]
	B6 -> B8 [label=false]
	B8 -> B9 [label=""]
	B9 -> B10 [label=true]
	B9 -> B11 [label=false]
	B10 -> B11 [label=""]
	B11 -> B12 [label="loop-body"]
	B12 -> B11 [label="back-edge"]
	B12 -> B13 [label=""]
	B13 -> B14 [label=true]
	B13 -> B15 [label=false]
	B14 -> B15 [label=true]
	B14 -> B16 [label=false]
	B16 -> B17 [label=""]
	B17 -> B18 [label=true]
	B17 -> B19 [label=false]
	B18 -> B19 [label=""]
	B20 -> B21 [label=""]
	B21 -> B22 [label=true]
	B21 -> B23 [label=false]
	B22 -> B23 [label=true]
	B22 -> B24 [label=false]
	B24 -> B25 [label=""]
	B25 -> B26 [label="loop-body"]
	B26 -> B25 [label="back-edge"]
	B27 -> B28 [label=""]
	B28 -> B29 [label=true]
	B28 -> B30 [label=false]
	B29 -> B30 [label=true]
	B29 -> B31 [label=false]
	B30 -> B31 [label=true]
	B30 -> B32 [label=false]
	B31 -> B32 [label=""]
	B32 -> B33 [label=true]
	B32 -> B34 [label=false]
	B36 -> B37 [label=""]
	B37 -> B38 [label=true]
	B37 -> B39 [label=false]
	B38 -> B39 [label=""]
	B39 -> B40 [label=true]
	B39 -> B41 [label=false]
	B40 -> B41 [label=""]
	B41 -> B42 [label=true]
	B41 -> B43 [label=false]
	B42 -> B43 [label=""]
	B43 -> B44 [label=true]
	B43 -> B45 [label=false]
	B45 -> B46 [label=""]
	B46 -> B47 [label=true]
	B46 -> B48 [label=false]
	B48 -> B49 [label=""]
	B49 -> B50 [label=true]
	B49 -> B51 [label=false]
	B50 -> B51 [label=true]
	B50 -> B52 [label=false]
	B52 -> B53 [label=""]
	B53 -> B54 [label=true]
	B53 -> B55 [label=false]
	B54 -> B55 [label=""]
	B55 -> B56 [label=true]
	B55 -> B57 [label=false]
	B56 -> B57 [label=""]
	B57 -> B58 [label=""]
	B58 -> B59 [label=true]
	B58 -> B60 [label=false]
	B59 -> B60 [label=""]
	B60 -> B61 [label=true]
	B60 -> B62 [label=false]
	B62 -> B63 [label=""]
	B63 -> B64 [label=true]
	B63 -> B65 [label=false]
	B64 -> B65 [label=""]
	B65 -> B66 [label="loop-body"]
	B66 -> B65 [label="back-edge"]
	B66 -> B67 [label=""]
	B67 -> B68 [label=true]
	B67 -> B69 [label=false]
	B68 -> B69 [label=true]
	B68 -> B70 [label=false]
	B69 -> B70 [label=""]
	B70 -> B71 [label="loop-body"]
	B71 -> B70 [label="back-edge"]
	B71 -> B72 [label=true]
	B71 -> B73 [label=false]
	B72 -> B73 [label=""]
	B73 -> B74 [label=true]
	B73 -> B75 [label=false]
	B74 -> B75 [label=""]
	B75 -> B76 [label="loop-body"]
	B76 -> B75 [label="back-edge"]
	B77 -> B78 [label=""]
	B78 -> B79 [label="loop-body"]
	B79 -> B78 [label="back-edge"]
	B79 -> B80 [label=true]
	B79 -> B81 [label=false]
	B80 -> B81 [label=""]
	B81 -> B82 [label=true]
	B81 -> B83 [label=false]
	B82 -> B83 [label=""]
	B83 -> B84 [label="loop-body"]
	B84 -> B83 [label="back-edge"]
	B85 -> B86 [label=""]
	B86 -> B87 [label=true]
	B86 -> B88 [label=false]
	B88 -> B89 [label=""]
	B89 -> B90 [label=true]
	B89 -> B91 [label=false]
	B90 -> B91 [label=true]
	B90 -> B92 [label=false]
	B92 -> B93 [label=""]
	B93 -> B94 [label=true]
	B93 -> B95 [label=false]
	B94 -> B95 [label=""]
	B95 -> B96 [label="loop-body"]
	B96 -> B95 [label="back-edge"]
	B96 -> B97 [label=""]
	B97 -> B98 [label=true]
	B97 -> B99 [label=false]
	B98 -> B99 [label=""]
	B99 -> B100 [label="loop-body"]
	B100 -> B99 [label="back-edge"]
	B100 -> B101 [label=""]
	B101 -> B102 [label=true]
	B101 -> B103 [label=false]
	B102 -> B103 [label=""]
	B103 -> B104 [label=true]
	B103 -> B105 [label=false]
	B104 -> B105 [label=""]
	B105 -> B106 [label=true]
	B105 -> B107 [label=false]
	B106 -> B107 [label=""]
	B107 -> B108 [label=true]
	B107 -> B109 [label=false]
	B108 -> B109 [label=""]
	B109 -> B110 [label=true]
	B109 -> B111 [label=false]
	B110 -> B111 [label=""]
	B111 -> B112 [label=""]
	B112 -> B113 [label=true]
	B112 -> B114 [label=false]
	B113 -> B114 [label=""]
	B114 -> B115 [label=true]
	B114 -> B116 [label=false]
	B115 -> B116 [label=""]
	B116 -> B117 [label=true]
	B116 -> B118 [label=false]
	B117 -> B118 [label=true]
	B117 -> B119 [label=false]
	B118 -> B119 [label=""]
	B119 -> B120 [label=true]
	B119 -> B121 [label=false]
	B120 -> B121 [label=""]
	B121 -> B122 [label=true]
	B121 -> B123 [label=false]
	B122 -> B123 [label=""]
	B123 -> B124 [label=""]
	B124 -> B125 [label=true]
	B124 -> B126 [label=false]
	B125 -> B126 [label=""]
	B126 -> B127 [label=true]
	B126 -> B128 [label=false]
	B127 -> B128 [label=""]
}
